<?php

class A
{

    public static function test(int $x)         // статические свойства принадлежат классам, а не объектам.
    {                                           // то есть их использовать можно даже без создания обьектов
        return 'x = '. $x;
    }
}

echo A::test(5);

// становится понятно, что статические свойства и методы нужны, либо когда нам не требуется объект как таковой,
// либо его пока нет, но мы хотим создать объект с какими-то значениями по-умолчанию.

class User
{
    private $role;
    private $name;

    public function __construct(string $role, string $name)
    {
        $this->role = $role;
        $this->name = $name;
    }

    // с помощью конструктора можем создавать пользователей с разными ролями (модератор, администратор, простой
    //пользователь) и именами.
    //$admin = new User('admin', 'Иван');

    // С помощью статического метода мы можем создать объекты этого класса, с указанием каких-либо значений по умолчанию.
    // Например, можем сделать метод, который будет создавать администраторов, и ему на вход нужно будет только имя пользователя.

    public static function createAdmin(string $name)
    {
        return new self ('admin', $name);       // превращает новый объект текущего класса благодаря self, и
                                                    // передает ему всегда в аргумент $role значение 'admin'
    }
    // $admin = User::createAdmin('Иван');
    // var_dump($admin);

}
$admin = User::createAdmin('Иван');
var_dump($admin);

/*В данном упрощенном примере, может показаться, что такой метод мало чем полезен, однако представьте, как будет удобно,
 если таких параметров в конструкторе будет 5, и из них 4 можно будет сделать для какого-то рода объектов всегда
одинаковыми. В таком случае статический метод, порождающий объекты, становится изящным способом упростить код.*/

/*В отличие от методов объектов, в статических методах нет слова $this – оно указывает только на текущий объект.
Если объекта нет – нет и $this!*/

class Abc
{
    public static $x;

    public function getX() // так как статические свойства принадлежат классу, а не объектам, мы можем использовать
                            // их в статических методах при помощи слова self::.
    {
        return self::$x;
    }
}

// мы можем читать и писать в это свойство, не создавая объектов этого класса:
Abc::$x = 5;
var_dump(Abc::$x); //5

// кроме того, эти же свойства будут доступны и у объектов этого класса:
$a = new Abc();
var_dump($a::$x); //5

var_dump($a->getX());

/*Давайте создадим в классе Human статическую переменную $count, и сделаем её приватной, чтобы изменять её можно
было только внутри класса.
*/

class Human
{
    private static $count = 0;

    public function __construct() // конструктор вызывается каждый раз когда создается объект, поэтому:
    {
        self::$count++;
    }

    public static function getCount()
    {
        return self::$count;
    }
}

$human1 = new Human();
$human2 = new Human();
$human3 = new Human();
echo 'Людей уже ' . Human::getCount();